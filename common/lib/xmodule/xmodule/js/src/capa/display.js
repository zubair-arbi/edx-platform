// Generated by CoffeeScript 1.4.0
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  this.Problem = (function() {
    var _this = this;

    function Problem(element) {
      this.refreshAnswers = __bind(this.refreshAnswers, this);

      this.updateMathML = __bind(this.updateMathML, this);

      this.refreshMath = __bind(this.refreshMath, this);

      this.save = __bind(this.save, this);

      this.gentle_alert = __bind(this.gentle_alert, this);

      this.show = __bind(this.show, this);

      this.reset = __bind(this.reset, this);

      this.check = __bind(this.check, this);

      this.check_fd = __bind(this.check_fd, this);

      this.setupInputTypes = __bind(this.setupInputTypes, this);

      this.poll = __bind(this.poll, this);

      this.get_queuelen = __bind(this.get_queuelen, this);

      this.queueing = __bind(this.queueing, this);

      this.updateProgress = __bind(this.updateProgress, this);

      this.bind = __bind(this.bind, this);
      this.el = $(element).find('.problems-wrapper');
      this.id = this.el.data('problem-id');
      this.element_id = this.el.attr('id');
      this.url = this.el.data('url');
      this.render();
    }

    Problem.prototype.$ = function(selector) {
      return $(selector, this.el);
    };

    Problem.prototype.bind = function() {
      var problem_prefix,
        _this = this;
      if (typeof MathJax !== "undefined" && MathJax !== null) {
        this.el.find('.problem > div').each(function(index, element) {
          return MathJax.Hub.Queue(["Typeset", MathJax.Hub, element]);
        });
      }
      window.update_schematics();
      problem_prefix = this.element_id.replace(/problem_/, '');
      this.inputs = this.$("[id^=input_" + problem_prefix + "_]");
      this.$('section.action input:button').click(this.refreshAnswers);
      this.$('section.action input.check').click(this.check_fd);
      this.$('section.action input.reset').click(this.reset);
      this.$('section.action input.show').click(this.show);
      this.$('section.action input.save').click(this.save);
      Collapsible.setCollapsibles(this.el);
      this.$('input.math').keyup(this.refreshMath);
      if (typeof MathJax !== "undefined" && MathJax !== null) {
        return this.$('input.math').each(function(index, element) {
          return MathJax.Hub.Queue([_this.refreshMath, null, element]);
        });
      }
    };

    Problem.prototype.updateProgress = function(response) {
      if (response.progress_changed) {
        this.el.attr({
          progress: response.progress_status
        });
        return this.el.trigger('progressChanged');
      }
    };

    Problem.prototype.queueing = function() {
      var queuelen;
      this.queued_items = this.$(".xqueue");
      this.num_queued_items = this.queued_items.length;
      if (this.num_queued_items > 0) {
        if (window.queuePollerID) {
          window.clearTimeout(window.queuePollerID);
        }
        queuelen = this.get_queuelen();
        return window.queuePollerID = window.setTimeout(this.poll, queuelen * 10);
      }
    };

    Problem.prototype.get_queuelen = function() {
      var minlen;
      minlen = Infinity;
      this.queued_items.each(function(index, qitem) {
        var len;
        len = parseInt($.text(qitem));
        if (len < minlen) {
          return minlen = len;
        }
      });
      return minlen;
    };

    Problem.prototype.poll = function() {
      var _this = this;
      return $.postWithPrefix("" + this.url + "/problem_get", function(response) {
        _this.new_queued_items = $(response.html).find(".xqueue");
        if (_this.new_queued_items.length !== _this.num_queued_items) {
          _this.el.html(response.html);
          JavascriptLoader.executeModuleScripts(_this.el, function() {
            _this.setupInputTypes();
            return _this.bind();
          });
        }
        _this.num_queued_items = _this.new_queued_items.length;
        if (_this.num_queued_items === 0) {
          return delete window.queuePollerID;
        } else {
          return window.queuePollerID = window.setTimeout(_this.poll, 1000);
        }
      });
    };

    Problem.prototype.render = function(content) {
      var _this = this;
      if (content) {
        this.el.html(content);
        return JavascriptLoader.executeModuleScripts(this.el, function() {
          _this.setupInputTypes();
          _this.bind();
          return _this.queueing();
        });
      } else {
        return $.postWithPrefix("" + this.url + "/problem_get", function(response) {
          _this.el.html(response.html);
          return JavascriptLoader.executeModuleScripts(_this.el, function() {
            _this.setupInputTypes();
            _this.bind();
            return _this.queueing();
          });
        });
      }
    };

    Problem.prototype.setupInputTypes = function() {
      var _this = this;
      this.inputtypeDisplays = {};
      return this.el.find(".capa_inputtype").each(function(index, inputtype) {
        var classes, cls, id, setupMethod, _i, _len, _results;
        classes = $(inputtype).attr('class').split(' ');
        id = $(inputtype).attr('id');
        _results = [];
        for (_i = 0, _len = classes.length; _i < _len; _i++) {
          cls = classes[_i];
          setupMethod = _this.inputtypeSetupMethods[cls];
          if (setupMethod != null) {
            _results.push(_this.inputtypeDisplays[id] = setupMethod(inputtype));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      });
    };

    /*
      # 'check_fd' uses FormData to allow file submissions in the 'problem_check' dispatch,
      #      in addition to simple querystring-based answers
      #
      # NOTE: The dispatch 'problem_check' is being singled out for the use of FormData;
      #       maybe preferable to consolidate all dispatches to use FormData
    */


    Problem.prototype.check_fd = function() {
      var abort_submission, error, error_html, errors, fd, file_not_selected, file_too_large, max_filesize, required_files_not_submitted, settings, unallowed_file_submitted, _i, _len,
        _this = this;
      Logger.log('problem_check', this.answers);
      if ($('input:file').length === 0) {
        this.check();
        return;
      }
      if (!window.FormData) {
        alert("Submission aborted! Sorry, your browser does not support file uploads. If you can, please use Chrome or Safari which have been verified to support file uploads.");
        return;
      }
      fd = new FormData();
      max_filesize = 4 * 1000 * 1000;
      file_too_large = false;
      file_not_selected = false;
      required_files_not_submitted = false;
      unallowed_file_submitted = false;
      errors = [];
      this.inputs.each(function(index, element) {
        var allowed_files, file, required_files, _i, _len, _ref, _ref1, _ref2;
        if (element.type === 'file') {
          required_files = $(element).data("required_files");
          allowed_files = $(element).data("allowed_files");
          _ref = element.files;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            file = _ref[_i];
            if (allowed_files.length !== 0 && (_ref1 = file.name, __indexOf.call(allowed_files, _ref1) < 0)) {
              unallowed_file_submitted = true;
              errors.push("You submitted " + file.name + "; only " + allowed_files + " are allowed.");
            }
            if (_ref2 = file.name, __indexOf.call(required_files, _ref2) >= 0) {
              required_files.splice(required_files.indexOf(file.name), 1);
            }
            if (file.size > max_filesize) {
              file_too_large = true;
              errors.push('Your file "' + file.name('" is too large (max size: ' + max_filesize / (1000 * 1000) + ' MB)'));
            }
            fd.append(element.id, file);
          }
          if (element.files.length === 0) {
            file_not_selected = true;
            fd.append(element.id, '');
          }
          if (required_files.length !== 0) {
            required_files_not_submitted = true;
            return errors.push("You did not submit the required files: " + required_files + ".");
          }
        } else {
          return fd.append(element.id, element.value);
        }
      });
      if (file_not_selected) {
        errors.push('You did not select any files to submit');
      }
      error_html = '<ul>\n';
      for (_i = 0, _len = errors.length; _i < _len; _i++) {
        error = errors[_i];
        error_html += '<li>' + error + '</li>\n';
      }
      error_html += '</ul>';
      this.gentle_alert(error_html);
      abort_submission = file_too_large || file_not_selected || unallowed_file_submitted || required_files_not_submitted;
      settings = {
        type: "POST",
        data: fd,
        processData: false,
        contentType: false,
        success: function(response) {
          switch (response.success) {
            case 'incorrect':
            case 'correct':
              _this.render(response.contents);
              return _this.updateProgress(response);
            default:
              return _this.gentle_alert(response.success);
          }
        }
      };
      if (!abort_submission) {
        return $.ajaxWithPrefix("" + this.url + "/problem_check", settings);
      }
    };

    Problem.prototype.check = function() {
      var _this = this;
      Logger.log('problem_check', this.answers);
      return $.postWithPrefix("" + this.url + "/problem_check", this.answers, function(response) {
        switch (response.success) {
          case 'incorrect':
          case 'correct':
            _this.render(response.contents);
            _this.updateProgress(response);
            if (_this.el.hasClass('showed')) {
              return _this.el.removeClass('showed');
            }
            break;
          default:
            return _this.gentle_alert(response.success);
        }
      });
    };

    Problem.prototype.reset = function() {
      var _this = this;
      Logger.log('problem_reset', this.answers);
      return $.postWithPrefix("" + this.url + "/problem_reset", {
        id: this.id
      }, function(response) {
        _this.render(response.html);
        return _this.updateProgress(response);
      });
    };

    Problem.prototype.show = function() {
      var _this = this;
      if (!this.el.hasClass('showed')) {
        Logger.log('problem_show', {
          problem: this.id
        });
        return $.postWithPrefix("" + this.url + "/problem_show", function(response) {
          var answers;
          answers = response.answers;
          $.each(answers, function(key, value) {
            var answer, choice, _i, _len, _results;
            if ($.isArray(value)) {
              _results = [];
              for (_i = 0, _len = value.length; _i < _len; _i++) {
                choice = value[_i];
                _results.push(_this.$("label[for='input_" + key + "_" + choice + "']").attr({
                  correct_answer: 'true'
                }));
              }
              return _results;
            } else {
              answer = _this.$("#answer_" + key + ", #solution_" + key);
              answer.html(value);
              return Collapsible.setCollapsibles(answer);
            }
          });
          _this.el.find(".capa_inputtype").each(function(index, inputtype) {
            var classes, cls, display, showMethod, _i, _len, _results;
            classes = $(inputtype).attr('class').split(' ');
            _results = [];
            for (_i = 0, _len = classes.length; _i < _len; _i++) {
              cls = classes[_i];
              display = _this.inputtypeDisplays[$(inputtype).attr('id')];
              showMethod = _this.inputtypeShowAnswerMethods[cls];
              if (showMethod != null) {
                _results.push(showMethod(inputtype, display, answers));
              } else {
                _results.push(void 0);
              }
            }
            return _results;
          });
          if (typeof MathJax !== "undefined" && MathJax !== null) {
            _this.el.find('.problem > div').each(function(index, element) {
              return MathJax.Hub.Queue(["Typeset", MathJax.Hub, element]);
            });
          }
          _this.$('.show').val('Hide Answer');
          _this.el.addClass('showed');
          return _this.updateProgress(response);
        });
      } else {
        this.$('[id^=answer_], [id^=solution_]').text('');
        this.$('[correct_answer]').attr({
          correct_answer: null
        });
        this.el.removeClass('showed');
        this.$('.show').val('Show Answer');
        return this.el.find(".capa_inputtype").each(function(index, inputtype) {
          var classes, cls, display, hideMethod, _i, _len, _results;
          display = _this.inputtypeDisplays[$(inputtype).attr('id')];
          classes = $(inputtype).attr('class').split(' ');
          _results = [];
          for (_i = 0, _len = classes.length; _i < _len; _i++) {
            cls = classes[_i];
            hideMethod = _this.inputtypeHideAnswerMethods[cls];
            if (hideMethod != null) {
              _results.push(hideMethod(inputtype, display));
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        });
      }
    };

    Problem.prototype.gentle_alert = function(msg) {
      var alert_elem;
      if (this.el.find('.capa_alert').length) {
        this.el.find('.capa_alert').remove();
      }
      alert_elem = "<div class='capa_alert'>" + msg + "</div>";
      this.el.find('.action').after(alert_elem);
      return this.el.find('.capa_alert').css({
        opacity: 0
      }).animate({
        opacity: 1
      }, 700);
    };

    Problem.prototype.save = function() {
      var _this = this;
      Logger.log('problem_save', this.answers);
      return $.postWithPrefix("" + this.url + "/problem_save", this.answers, function(response) {
        var saveMessage;
        saveMessage = response.msg;
        _this.gentle_alert(saveMessage);
        return _this.updateProgress(response);
      });
    };

    Problem.prototype.refreshMath = function(event, element) {
      var elid, eqn, jax, mathjax_preprocessor, preprocessor_tag, target;
      if (!element) {
        element = event.target;
      }
      elid = element.id.replace(/^input_/, '');
      target = "display_" + elid;
      preprocessor_tag = "inputtype_" + elid;
      mathjax_preprocessor = this.inputtypeDisplays[preprocessor_tag];
      if ((typeof MathJax !== "undefined" && MathJax !== null) && (jax = MathJax.Hub.getAllJax(target)[0])) {
        eqn = $(element).val();
        if (mathjax_preprocessor) {
          eqn = mathjax_preprocessor(eqn);
        }
        MathJax.Hub.Queue(['Text', jax, eqn], [this.updateMathML, jax, element]);
      }
    };

    Problem.prototype.updateMathML = function(jax, element) {
      try {
        return $("#" + element.id + "_dynamath").val(jax.root.toMathML(''));
      } catch (exception) {
        if (!exception.restart) {
          throw exception;
        }
        if (typeof MathJax !== "undefined" && MathJax !== null) {
          return MathJax.Callback.After([this.refreshMath, jax], exception.restart);
        }
      }
    };

    Problem.prototype.refreshAnswers = function() {
      this.$('input.schematic').each(function(index, element) {
        return element.schematic.update_value();
      });
      this.$(".CodeMirror").each(function(index, element) {
        if (element.CodeMirror.save) {
          return element.CodeMirror.save();
        }
      });
      return this.answers = this.inputs.serialize();
    };

    Problem.prototype.inputtypeSetupMethods = {
      'text-input-dynamath': function(element) {
        /*
              Return: function (eqn) -> eqn that preprocesses the user formula input before
                        it is fed into MathJax. Return 'false' if no preprocessor specified
        */

        var data, preprocessor, preprocessorClass, preprocessorClassName;
        data = $(element).find('.text-input-dynamath_data');
        preprocessorClassName = data.data('preprocessor');
        preprocessorClass = window[preprocessorClassName];
        if (!(preprocessorClass != null)) {
          return false;
        } else {
          preprocessor = new preprocessorClass();
          return preprocessor.fn;
        }
      },
      javascriptinput: function(element) {
        var container, data, display, displayClass, evaluation, params, problemState, submission, submissionField;
        data = $(element).find(".javascriptinput_data");
        params = data.data("params");
        submission = data.data("submission");
        evaluation = data.data("evaluation");
        problemState = data.data("problem_state");
        displayClass = window[data.data('display_class')];
        if (evaluation === '') {
          evaluation = null;
        }
        container = $(element).find(".javascriptinput_container");
        submissionField = $(element).find(".javascriptinput_input");
        display = new displayClass(problemState, submission, evaluation, container, submissionField, params);
        display.render();
        return display;
      }
    };

    Problem.prototype.inputtypeShowAnswerMethods = {
      choicegroup: function(element, display, answers) {
        var answer, choice, input_id, _i, _len, _results;
        element = $(element);
        element.find('input').attr('disabled', 'disabled');
        input_id = element.attr('id').replace(/inputtype_/, '');
        answer = answers[input_id];
        _results = [];
        for (_i = 0, _len = answer.length; _i < _len; _i++) {
          choice = answer[_i];
          _results.push(element.find("label[for='input_" + input_id + "_" + choice + "']").addClass('choicegroup_correct'));
        }
        return _results;
      },
      javascriptinput: function(element, display, answers) {
        var answer, answer_id;
        answer_id = $(element).attr('id').split("_").slice(1).join("_");
        answer = JSON.parse(answers[answer_id]);
        return display.showAnswer(answer);
      }
    };

    Problem.prototype.inputtypeHideAnswerMethods = {
      choicegroup: function(element, display) {
        element = $(element);
        element.find('input').attr('disabled', null);
        return element.find('label').removeClass('choicegroup_correct');
      },
      javascriptinput: function(element, display) {
        return display.hideAnswer();
      }
    };

    return Problem;

  }).call(this);

}).call(this);
