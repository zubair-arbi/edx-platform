// Generated by CoffeeScript 1.4.0
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  this.MarkdownEditingDescriptor = (function(_super) {

    __extends(MarkdownEditingDescriptor, _super);

    MarkdownEditingDescriptor.multipleChoiceTemplate = "( ) incorrect\n( ) incorrect\n(x) correct\n";

    MarkdownEditingDescriptor.checkboxChoiceTemplate = "[x] correct\n[ ] incorrect\n[x] correct\n";

    MarkdownEditingDescriptor.stringInputTemplate = "= answer\n";

    MarkdownEditingDescriptor.numberInputTemplate = "= answer +- x%\n";

    MarkdownEditingDescriptor.selectTemplate = "[[incorrect, (correct), incorrect]]\n";

    MarkdownEditingDescriptor.headerTemplate = "Header\n=====\n";

    MarkdownEditingDescriptor.explanationTemplate = "[explanation]\nShort explanation\n[explanation]\n";

    function MarkdownEditingDescriptor(element) {
      this.toggleCheatsheet = __bind(this.toggleCheatsheet, this);

      this.onToolbarButton = __bind(this.onToolbarButton, this);

      this.onShowXMLButton = __bind(this.onShowXMLButton, this);
      this.element = element;
      if ($(".markdown-box", this.element).length !== 0) {
        this.markdown_editor = CodeMirror.fromTextArea($(".markdown-box", element)[0], {
          lineWrapping: true,
          mode: null
        });
        this.setCurrentEditor(this.markdown_editor);
        this.element.on('click', '.xml-tab', this.onShowXMLButton);
        this.element.on('click', '.format-buttons a', this.onToolbarButton);
        this.element.on('click', '.cheatsheet-toggle', this.toggleCheatsheet);
        $(this.element.find('.xml-box')).hide();
      } else {
        this.createXMLEditor();
      }
    }

    /*
      Creates the XML Editor and sets it as the current editor. If text is passed in,
      it will replace the text present in the HTML template.
    
      text: optional argument to override the text passed in via the HTML template
    */


    MarkdownEditingDescriptor.prototype.createXMLEditor = function(text) {
      this.xml_editor = CodeMirror.fromTextArea($(".xml-box", this.element)[0], {
        mode: "xml",
        lineNumbers: true,
        lineWrapping: true
      });
      if (text) {
        this.xml_editor.setValue(text);
      }
      return this.setCurrentEditor(this.xml_editor);
    };

    /*
      User has clicked to show the XML editor. Before XML editor is swapped in,
      the user will need to confirm the one-way conversion.
    */


    MarkdownEditingDescriptor.prototype.onShowXMLButton = function(e) {
      e.preventDefault();
      if (this.confirmConversionToXml()) {
        this.createXMLEditor(MarkdownEditingDescriptor.markdownToXml(this.markdown_editor.getValue()));
        this.xml_editor.setCursor(0);
        this.xml_editor.refresh();
        return $(this.element.find('.editor-bar')).hide();
      }
    };

    /*
      Have the user confirm the one-way conversion to XML.
      Returns true if the user clicked OK, else false.
    */


    MarkdownEditingDescriptor.prototype.confirmConversionToXml = function() {
      return confirm("If you use the Advanced Editor, this problem will be converted to XML and you will not be able to return to the Simple Editor Interface.\n\nProceed to the Advanced Editor and convert this problem to XML?");
    };

    /*
      Event listener for toolbar buttons (only possible when markdown editor is visible).
    */


    MarkdownEditingDescriptor.prototype.onToolbarButton = function(e) {
      var revisedSelection, selection;
      e.preventDefault();
      selection = this.markdown_editor.getSelection();
      revisedSelection = null;
      switch ($(e.currentTarget).attr('class')) {
        case "multiple-choice-button":
          revisedSelection = MarkdownEditingDescriptor.insertMultipleChoice(selection);
          break;
        case "string-button":
          revisedSelection = MarkdownEditingDescriptor.insertStringInput(selection);
          break;
        case "number-button":
          revisedSelection = MarkdownEditingDescriptor.insertNumberInput(selection);
          break;
        case "checks-button":
          revisedSelection = MarkdownEditingDescriptor.insertCheckboxChoice(selection);
          break;
        case "dropdown-button":
          revisedSelection = MarkdownEditingDescriptor.insertSelect(selection);
          break;
        case "header-button":
          revisedSelection = MarkdownEditingDescriptor.insertHeader(selection);
          break;
        case "explanation-button":
          revisedSelection = MarkdownEditingDescriptor.insertExplanation(selection);
          break;
      }
      if (revisedSelection !== null) {
        this.markdown_editor.replaceSelection(revisedSelection);
        return this.markdown_editor.focus();
      }
    };

    /*
      Event listener for toggling cheatsheet (only possible when markdown editor is visible).
    */


    MarkdownEditingDescriptor.prototype.toggleCheatsheet = function(e) {
      var _this = this;
      e.preventDefault();
      if (!$(this.markdown_editor.getWrapperElement()).find('.simple-editor-cheatsheet')[0]) {
        this.cheatsheet = $($('#simple-editor-cheatsheet').html());
        $(this.markdown_editor.getWrapperElement()).append(this.cheatsheet);
      }
      return setTimeout((function() {
        return _this.cheatsheet.toggleClass('shown');
      }), 10);
    };

    /*
      Stores the current editor and hides the one that is not displayed.
    */


    MarkdownEditingDescriptor.prototype.setCurrentEditor = function(editor) {
      if (this.current_editor) {
        $(this.current_editor.getWrapperElement()).hide();
      }
      this.current_editor = editor;
      $(this.current_editor.getWrapperElement()).show();
      return $(this.current_editor).focus();
    };

    /*
      Called when save is called. Listeners are unregistered because editing the block again will
      result in a new instance of the descriptor. Note that this is NOT the case for cancel--
      when cancel is called the instance of the descriptor is reused if edit is selected again.
    */


    MarkdownEditingDescriptor.prototype.save = function() {
      this.element.off('click', '.xml-tab', this.changeEditor);
      this.element.off('click', '.format-buttons a', this.onToolbarButton);
      this.element.off('click', '.cheatsheet-toggle', this.toggleCheatsheet);
      if (this.current_editor === this.markdown_editor) {
        return {
          data: MarkdownEditingDescriptor.markdownToXml(this.markdown_editor.getValue()),
          metadata: {
            markdown: this.markdown_editor.getValue()
          }
        };
      } else {
        return {
          data: this.xml_editor.getValue(),
          metadata: {
            markdown: null
          }
        };
      }
    };

    MarkdownEditingDescriptor.insertMultipleChoice = function(selectedText) {
      return MarkdownEditingDescriptor.insertGenericChoice(selectedText, '(', ')', MarkdownEditingDescriptor.multipleChoiceTemplate);
    };

    MarkdownEditingDescriptor.insertCheckboxChoice = function(selectedText) {
      return MarkdownEditingDescriptor.insertGenericChoice(selectedText, '[', ']', MarkdownEditingDescriptor.checkboxChoiceTemplate);
    };

    MarkdownEditingDescriptor.insertGenericChoice = function(selectedText, choiceStart, choiceEnd, template) {
      var cleanSelectedText, line, lines, revisedLines, _i, _len;
      if (selectedText.length > 0) {
        cleanSelectedText = selectedText.replace(/\n+/g, '\n').replace(/\n$/, '');
        lines = cleanSelectedText.split('\n');
        revisedLines = '';
        for (_i = 0, _len = lines.length; _i < _len; _i++) {
          line = lines[_i];
          revisedLines += choiceStart;
          if (/^\s*x\s+(\S)/i.test(line)) {
            line = line.replace(/^\s*x\s+(\S)/i, '$1');
            revisedLines += 'x';
          } else {
            revisedLines += ' ';
          }
          revisedLines += choiceEnd + ' ' + line + '\n';
        }
        return revisedLines;
      } else {
        return template;
      }
    };

    MarkdownEditingDescriptor.insertStringInput = function(selectedText) {
      return MarkdownEditingDescriptor.insertGenericInput(selectedText, '= ', '', MarkdownEditingDescriptor.stringInputTemplate);
    };

    MarkdownEditingDescriptor.insertNumberInput = function(selectedText) {
      return MarkdownEditingDescriptor.insertGenericInput(selectedText, '= ', '', MarkdownEditingDescriptor.numberInputTemplate);
    };

    MarkdownEditingDescriptor.insertSelect = function(selectedText) {
      return MarkdownEditingDescriptor.insertGenericInput(selectedText, '[[', ']]', MarkdownEditingDescriptor.selectTemplate);
    };

    MarkdownEditingDescriptor.insertHeader = function(selectedText) {
      return MarkdownEditingDescriptor.insertGenericInput(selectedText, '', '\n====\n', MarkdownEditingDescriptor.headerTemplate);
    };

    MarkdownEditingDescriptor.insertExplanation = function(selectedText) {
      return MarkdownEditingDescriptor.insertGenericInput(selectedText, '[explanation]\n', '\n[explanation]', MarkdownEditingDescriptor.explanationTemplate);
    };

    MarkdownEditingDescriptor.insertGenericInput = function(selectedText, lineStart, lineEnd, template) {
      if (selectedText.length > 0) {
        return lineStart + selectedText + lineEnd;
      } else {
        return template;
      }
    };

    MarkdownEditingDescriptor.markdownToXml = function(markdown) {
      var toXml;
      toXml = function(markdown) {
      var xml = markdown;

      // replace headers
      xml = xml.replace(/(^.*?$)(?=\n\=\=+$)/gm, '<h1>$1</h1>');
      xml = xml.replace(/\n^\=\=+$/gm, '');

      // group multiple choice answers
      xml = xml.replace(/(^\s*\(.?\).*?$\n*)+/gm, function(match, p) {
        var groupString = '<multiplechoiceresponse>\n';
        groupString += '  <choicegroup type="MultipleChoice">\n';
        var options = match.split('\n');
        for(var i = 0; i < options.length; i++) {
          if(options[i].length > 0) {
            var value = options[i].split(/^\s*\(.?\)\s*/)[1];
            var correct = /^\s*\(x\)/i.test(options[i]);
            groupString += '    <choice correct="' + correct + '">' + value + '</choice>\n';
          }
        }
        groupString += '  </choicegroup>\n';
        groupString += '</multiplechoiceresponse>\n\n';
        return groupString;
      });

      // group check answers
      xml = xml.replace(/(^\s*\[.?\].*?$\n*)+/gm, function(match, p) {
        var groupString = '<choiceresponse>\n';
        groupString += '  <checkboxgroup direction="vertical">\n';
        var options = match.split('\n');
        for(var i = 0; i < options.length; i++) {
          if(options[i].length > 0) {
            var value = options[i].split(/^\s*\[.?\]\s*/)[1];
            var correct = /^\s*\[x\]/i.test(options[i]);
            groupString += '    <choice correct="' + correct + '">' + value + '</choice>\n';
          }
        }
        groupString += '  </checkboxgroup>\n';
        groupString += '</choiceresponse>\n\n';
        return groupString;
      });

      // replace string and numerical
      xml = xml.replace(/^\=\s*(.*?$)/gm, function(match, p) {
        var string;
        var floatValue = parseFloat(p);
        if(!isNaN(floatValue)) {
          var params = /(.*?)\+\-\s*(.*?$)/.exec(p);
          if(params) {
            string = '<numericalresponse answer="' + floatValue + '">\n';
            string += '  <responseparam type="tolerance" default="' + params[2] + '" />\n';
          } else {
            string = '<numericalresponse answer="' + floatValue + '">\n';
          }
          string += '  <textline />\n';
          string += '</numericalresponse>\n\n';
        } else {
          string = '<stringresponse answer="' + p + '" type="ci">\n  <textline size="20"/>\n</stringresponse>\n\n';
        }
        return string;
      });

      // replace selects
      xml = xml.replace(/\[\[(.+?)\]\]/g, function(match, p) {
        var selectString = '\n<optionresponse>\n';
        selectString += '  <optioninput options="(';
        var options = p.split(/\,\s*/g);
        for(var i = 0; i < options.length; i++) {
          selectString += "'" + options[i].replace(/(?:^|,)\s*\((.*?)\)\s*(?:$|,)/g, '$1') + "'" + (i < options.length -1 ? ',' : '');
        }
        selectString += ')" correct="';
        var correct = /(?:^|,)\s*\((.*?)\)\s*(?:$|,)/g.exec(p);
        if (correct) selectString += correct[1];
        selectString += '"></optioninput>\n';
        selectString += '</optionresponse>\n\n';
        return selectString;
      });
      
      // replace explanations
      xml = xml.replace(/\[explanation\]\n?([^\]]*)\[\/?explanation\]/gmi, function(match, p1) {
          var selectString = '<solution>\n<div class="detailed-solution">\nExplanation\n\n' + p1 + '\n</div>\n</solution>';
          return selectString;
      });

      // split scripts and wrap paragraphs
      var splits = xml.split(/(\<\/?script.*?\>)/g);
      var scriptFlag = false;
      for(var i = 0; i < splits.length; i++) {
        if(/\<script/.test(splits[i])) {
          scriptFlag = true;
        }
        if(!scriptFlag) {
          splits[i] = splits[i].replace(/(^(?!\s*\<|$).*$)/gm, '<p>$1</p>');
        }
        if(/\<\/script/.test(splits[i])) {
          scriptFlag = false;
        }
      }
      xml = splits.join('');

      // rid white space
      xml = xml.replace(/\n\n\n/g, '\n');
      
      // surround w/ problem tag
      xml = '<problem>\n' + xml + '\n</problem>';

      return xml;
    }
    ;
      return toXml(markdown);
    };

    return MarkdownEditingDescriptor;

  })(XModule.Descriptor);

}).call(this);
